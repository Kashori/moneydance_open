/* * ************************************************************************ * Copyright (C) 2015 MennÄ“ Software Solutions, LLC * * This code is released as open source under the Apache 2.0 License:<br/> * <a href="http://www.apache.org/licenses/LICENSE-2.0"> * http://www.apache.org/licenses/LICENSE-2.0</a><br /> * ************************************************************************ */package com.moneydance.modules.features.ratios;import com.infinitekind.moneydance.model.AbstractTxn;import com.infinitekind.moneydance.model.ParentTxn;import com.infinitekind.moneydance.model.SplitTxn;import com.infinitekind.moneydance.model.Txn;import com.infinitekind.moneydance.model.TxnSearch;import com.moneydance.apps.md.view.gui.TagLogic;import java.util.ArrayList;import java.util.List;public class TxnTagsFilter  implements TxnSearch {  private final List<String> _includedTags;  private final TagLogic _combineLogic;  TxnTagsFilter(final List<String> included, final TagLogic combine) {    _includedTags = new ArrayList<String>(included);    _combineLogic = combine;  }  public boolean matches(Txn txn) {    // only splits have value, and ratio calculations only need the transactions with value    if (txn instanceof ParentTxn) return false;    AbstractTxn searchTxn = null;    if (txn instanceof SplitTxn) {      searchTxn = (SplitTxn)txn;    } else {      // likely a FlippedSplitTxn, so get the other transaction to get the split from the FlippedSplitTxn      searchTxn = txn.getOtherTxn(0);    }    if (searchTxn == null) return false;  // unlikely    boolean isMatch;    if (TagLogic.EXACT.equals(_combineLogic)) {      isMatch = isExactMatch(searchTxn);    } else if (TagLogic.AND.equals(_combineLogic)) {      isMatch = isAllMatch(searchTxn);    } else {      isMatch = isAnyMatch(searchTxn); // OR logic    }    return isMatch;  }  public boolean matchesAll() {    return !TagLogic.EXACT.equals(_combineLogic) && _includedTags.isEmpty();  }  ///////////////////////////////////////////////////////////////////////////////////////////////  // Private Methods  ///////////////////////////////////////////////////////////////////////////////////////////////  private boolean isAllMatch(final AbstractTxn txn) {    // if the included tags are blank, that effectively disables the inclusion criteria and all transactions should match    if (_includedTags.isEmpty()) return true;    // the transaction can have a different number of tags, but must have all of the tags the user has included    List<String> splitTags = txn.getKeywords();    return splitTags.containsAll(_includedTags);  }  private boolean isAnyMatch(final AbstractTxn txn) {    // if the included tags are blank, that effectively disables the inclusion criteria and all transactions should match    if (_includedTags.isEmpty()) return true;    // the transaction must have at least one of the tags the user has chosen in order to match    List<String> splitTags = txn.getKeywords();    for (final String includedTag : _includedTags) {      if (splitTags.contains(includedTag)) {        return true;      }    }    return false;  }  private boolean isExactMatch(final AbstractTxn txn) {    // All tags defined in the split must be in the included tags, and the two lists must be the same size    final List<String> txnTags = txn.getKeywords();    if (txnTags.size() != _includedTags.size()) {      // can't be an exact match, included tags are defined and the split doesn't have any      return false;    }    return _includedTags.isEmpty() || txnTags.containsAll(_includedTags);  }}